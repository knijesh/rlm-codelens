<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Codebase Architecture Map</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }

        .container { max-width: 100%; margin: 0; display: flex; flex-direction: column; height: 100vh; }

        /* Header */
        .header {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            padding: 12px 25px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex; align-items: center; justify-content: space-between;
        }
        .header h1 { font-size: 20px; color: #fff; }
        .header p { color: #aaa; font-size: 12px; }

        /* Stats bar */
        .stats-bar {
            display: flex; gap: 20px; padding: 8px 25px;
            background: rgba(255,255,255,0.03);
            border-bottom: 1px solid rgba(255,255,255,0.08);
            flex-wrap: wrap; align-items: center;
        }
        .stat { text-align: center; }
        .stat-value { font-size: 18px; font-weight: bold; color: #4fc3f7; }
        .stat-label { font-size: 10px; color: #999; text-transform: uppercase; }
        .health-badge {
            padding: 4px 12px; border-radius: 12px; font-size: 11px;
            font-weight: bold; text-transform: uppercase; margin-left: auto;
        }
        .health-green { background: rgba(76,175,80,0.25); color: #66bb6a; border: 1px solid rgba(76,175,80,0.4); }
        .health-yellow { background: rgba(255,167,38,0.25); color: #ffa726; border: 1px solid rgba(255,167,38,0.4); }
        .health-red { background: rgba(229,57,53,0.25); color: #e53935; border: 1px solid rgba(229,57,53,0.4); }

        /* Main layout */
        .main { display: flex; flex: 1; overflow: hidden; }

        /* Sidebar */
        .sidebar {
            width: 260px; min-width: 260px;
            background: rgba(255,255,255,0.03);
            border-right: 1px solid rgba(255,255,255,0.08);
            padding: 12px; overflow-y: auto;
        }
        .sidebar h3 { font-size: 12px; color: #aaa; text-transform: uppercase; margin-bottom: 8px; letter-spacing: 0.5px; }
        .sidebar input[type="text"] {
            width: 100%; padding: 7px 10px; border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.05);
            color: #fff; font-size: 12px; margin-bottom: 12px; outline: none;
        }
        .sidebar input[type="text"]:focus { border-color: #4fc3f7; }

        .layer-filter { margin-bottom: 4px; display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 12px; }
        .layer-filter input { cursor: pointer; }
        .layer-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
        .layer-count { font-size: 10px; color: #777; margin-left: auto; }

        .section-header {
            display: flex; align-items: center; gap: 6px; cursor: pointer;
            margin-top: 14px; margin-bottom: 6px; user-select: none;
        }
        .section-header h3 { margin: 0; }
        .section-toggle { font-size: 10px; color: #777; transition: transform 0.2s; }
        .section-toggle.open { transform: rotate(90deg); }

        .metric-list { margin-top: 4px; }
        .metric-item {
            padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 11px; display: flex; justify-content: space-between; cursor: pointer;
        }
        .metric-item:hover { background: rgba(255,255,255,0.05); }
        .metric-item span:first-child { color: #ccc; max-width: 160px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .metric-item span:last-child { color: #4fc3f7; font-weight: bold; }

        .ap-item {
            padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 11px; cursor: pointer;
        }
        .ap-item:hover { background: rgba(255,255,255,0.05); }
        .ap-header { display: flex; justify-content: space-between; }
        .ap-details { color: #888; font-size: 10px; margin-top: 3px; display: none; line-height: 1.4; }
        .ap-item.expanded .ap-details { display: block; }

        .cycle-item {
            padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 11px; cursor: pointer; color: #e53935;
        }
        .cycle-item:hover { background: rgba(255,255,255,0.05); }

        /* Graph area */
        .graph-container { flex: 1; position: relative; }
        .graph-container svg { width: 100%; height: 100%; }

        /* Tooltip */
        .tooltip {
            position: absolute; padding: 10px 14px; border-radius: 8px;
            background: rgba(20,20,30,0.95); border: 1px solid rgba(255,255,255,0.15);
            font-size: 11px; pointer-events: none; max-width: 320px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5); z-index: 100; display: none;
        }
        .tooltip .tt-title { font-weight: bold; color: #fff; margin-bottom: 4px; font-size: 12px; }
        .tooltip .tt-row { display: flex; justify-content: space-between; margin-bottom: 2px; }
        .tooltip .tt-key { color: #aaa; }
        .tooltip .tt-val { color: #4fc3f7; margin-left: 10px; }
        .tooltip .tt-doc { color: #888; font-style: italic; margin-top: 4px; max-height: 50px; overflow: hidden; }

        /* Tracer panel (right side) */
        .tracer-panel {
            width: 0; overflow: hidden;
            background: rgba(15,20,30,0.98);
            border-left: 1px solid rgba(255,255,255,0.1);
            transition: width 0.3s ease;
            display: flex; flex-direction: column;
        }
        .tracer-panel.open { width: 340px; min-width: 340px; }
        .tracer-header {
            padding: 14px 16px; border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex; align-items: center; justify-content: space-between;
        }
        .tracer-header h2 { font-size: 14px; color: #fff; max-width: 270px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .tracer-close { background: none; border: none; color: #aaa; cursor: pointer; font-size: 18px; padding: 2px 6px; }
        .tracer-close:hover { color: #fff; }
        .tracer-body { padding: 12px 16px; overflow-y: auto; flex: 1; }

        .tracer-section { margin-bottom: 14px; }
        .tracer-section h4 {
            font-size: 11px; color: #aaa; text-transform: uppercase; margin-bottom: 6px;
            letter-spacing: 0.5px; border-bottom: 1px solid rgba(255,255,255,0.06); padding-bottom: 4px;
        }
        .tracer-row { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 3px; }
        .tracer-row .key { color: #999; }
        .tracer-row .val { color: #e0e0e0; }
        .layer-badge {
            display: inline-block; padding: 1px 8px; border-radius: 8px;
            font-size: 10px; font-weight: bold; text-transform: uppercase;
        }
        .tracer-doc { color: #888; font-size: 11px; font-style: italic; line-height: 1.4; max-height: 55px; overflow: hidden; }

        .dep-list { list-style: none; padding: 0; margin: 0; }
        .dep-list li {
            padding: 3px 6px; font-size: 11px; cursor: pointer; border-radius: 4px;
            margin-bottom: 2px; color: #ccc; display: flex; align-items: center; gap: 6px;
        }
        .dep-list li:hover { background: rgba(79,195,247,0.15); color: #4fc3f7; }
        .dep-list li .dep-arrow { color: #555; font-size: 10px; }

        /* Dependency tree */
        .dep-tree { padding-left: 0; }
        .dep-tree ul { padding-left: 14px; border-left: 1px solid rgba(255,255,255,0.06); margin: 0; list-style: none; }
        .dep-tree li {
            font-size: 11px; padding: 2px 4px; cursor: pointer; color: #bbb;
            border-radius: 3px; margin-bottom: 1px;
        }
        .dep-tree li:hover { background: rgba(79,195,247,0.1); color: #4fc3f7; }
        .dep-tree .tree-toggle { cursor: pointer; user-select: none; color: #666; margin-right: 4px; font-size: 10px; }

        .issues-list { font-size: 11px; }
        .issues-list .issue-tag {
            display: inline-block; padding: 2px 6px; border-radius: 4px;
            margin: 2px; font-size: 10px;
        }
        .issue-cycle { background: rgba(229,57,53,0.2); color: #e53935; border: 1px solid rgba(229,57,53,0.3); }
        .issue-ap { background: rgba(255,167,38,0.2); color: #ffa726; border: 1px solid rgba(255,167,38,0.3); }

        /* Legend */
        .legend {
            position: absolute; bottom: 12px; right: 12px;
            background: rgba(20,20,30,0.9); padding: 8px 12px;
            border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);
            font-size: 10px;
        }
        .legend-row { display: flex; align-items: center; gap: 6px; margin-bottom: 3px; }
        .legend-line { width: 22px; height: 0; display: inline-block; }
        .legend-line.solid { border-top: 2px solid #555; }
        .legend-line.dashed { border-top: 2px dashed #e53935; }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <div>
            <h1 id="title">Codebase Architecture Map</h1>
            <p id="subtitle">Interactive module dependency visualization</p>
        </div>
    </div>

    <div class="stats-bar" id="statsBar"></div>

    <div class="main">
        <div class="sidebar">
            <h3>Search</h3>
            <input type="text" id="searchInput" placeholder="Filter modules...">

            <h3>Layers</h3>
            <div id="layerFilters"></div>

            <div id="languageFilterSection" style="display:none;">
                <h3 style="margin-top:12px;">Languages</h3>
                <div id="languageFilters"></div>
            </div>

            <div class="section-header" id="hubHeader">
                <span class="section-toggle open">&#9654;</span>
                <h3>Hub Modules</h3>
            </div>
            <div class="metric-list" id="hubList"></div>

            <div class="section-header" id="apHeader">
                <span class="section-toggle open">&#9654;</span>
                <h3>Anti-Patterns</h3>
            </div>
            <div class="metric-list" id="antiPatternList"></div>

            <div class="section-header" id="cycleHeader">
                <span class="section-toggle open">&#9654;</span>
                <h3>Cycles</h3>
            </div>
            <div class="metric-list" id="cycleList"></div>
        </div>

        <div class="graph-container" id="graphContainer">
            <svg id="graphSvg"></svg>
            <div class="tooltip" id="tooltip"></div>
            <div class="legend">
                <div class="legend-row"><div class="legend-line solid"></div> AST import</div>
                <div class="legend-row"><div class="legend-line dashed"></div> Hidden dep (RLM)</div>
            </div>
        </div>

        <div class="tracer-panel" id="tracerPanel">
            <div class="tracer-header">
                <h2 id="tracerTitle">Module</h2>
                <button class="tracer-close" id="tracerClose">&times;</button>
            </div>
            <div class="tracer-body" id="tracerBody"></div>
        </div>
    </div>
</div>

<script>
// Layer color scheme
const LAYER_COLORS = {
    data:     "#42a5f5",
    business: "#66bb6a",
    api:      "#ffa726",
    util:     "#bdbdbd",
    test:     "#ab47bc",
    config:   "#ffee58",
};

const LAYER_ORDER = { config: 0, util: 1, data: 2, business: 3, api: 4, test: 5 };

// State
let allNodes = [], allLinks = [], allCycles = [], allAntiPatterns = [];
let nodeMap = {};
let simulation, svg, g, linkGroup, nodeGroup, labelGroup;
let activeFilters = new Set(Object.keys(LAYER_COLORS));
let activeLanguages = new Set();
let selectedNode = null;
let zoomBehavior;
let currentZoomScale = 0.7;

function init() {
    const data = typeof EMBEDDED_DATA !== "undefined" ? EMBEDDED_DATA : null;
    if (!data) { document.getElementById("title").textContent = "No data loaded"; return; }

    if (data.repository) {
        document.getElementById("title").textContent = data.repository + " — Architecture Map";
    }

    const gd = data.graph_data || {};
    allNodes = (gd.nodes || []).map(n => ({...n}));
    allLinks = (gd.links || []).map(l => ({...l}));
    allCycles = data.cycles || [];
    allAntiPatterns = data.anti_patterns || [];

    // Build node map
    allNodes.forEach(n => { nodeMap[n.id] = n; });

    // Detect languages present in the dataset
    allNodes.forEach(n => activeLanguages.add(n.language || "python"));

    renderStats(data);
    renderLayerFilters();
    renderLanguageFilters();
    renderHubModules(data.hub_modules || []);
    renderAntiPatterns(allAntiPatterns);
    renderCycles(allCycles);
    setupSidebarToggles();
    buildGraph();

    document.getElementById("searchInput").addEventListener("input", applyFilters);
    document.getElementById("tracerClose").addEventListener("click", closeTracer);
}

function renderStats(data) {
    const cycleCount = (data.cycles || []).length;
    const apCount = (data.anti_patterns || []).length;
    const highAp = (data.anti_patterns || []).filter(a => a.severity === "high").length;

    // Health score
    let healthClass = "health-green", healthText = "Healthy";
    if (cycleCount > 5 || highAp > 3) { healthClass = "health-red"; healthText = "Needs Attention"; }
    else if (cycleCount > 0 || highAp > 0) { healthClass = "health-yellow"; healthText = "Minor Issues"; }

    // Detect languages
    const langSet = new Set();
    (data.graph_data?.nodes || []).forEach(n => langSet.add(n.language || "python"));
    const langCount = langSet.size;

    const stats = [
        { label: "Modules", value: data.total_modules || 0 },
        { label: "Edges", value: data.total_edges || 0 },
        { label: "Languages", value: langCount },
        { label: "Cycles", value: cycleCount },
        { label: "Hub Modules", value: (data.hub_modules || []).length },
        { label: "Anti-Patterns", value: apCount },
        { label: "Total LOC", value: (data.total_loc || 0).toLocaleString() },
    ];

    const bar = document.getElementById("statsBar");
    bar.innerHTML = stats.map(s =>
        `<div class="stat"><div class="stat-value">${s.value}</div><div class="stat-label">${s.label}</div></div>`
    ).join("") + `<div class="health-badge ${healthClass}">${healthText}</div>`;
}

function renderLayerFilters() {
    const counts = {};
    allNodes.forEach(n => { counts[n.layer] = (counts[n.layer] || 0) + 1; });

    const container = document.getElementById("layerFilters");
    container.innerHTML = Object.entries(LAYER_COLORS).map(([layer, color]) =>
        `<label class="layer-filter">
            <input type="checkbox" checked data-layer="${layer}">
            <span class="layer-dot" style="background:${color}"></span>
            <span>${layer}</span>
            <span class="layer-count">${counts[layer] || 0}</span>
        </label>`
    ).join("");

    container.querySelectorAll("input").forEach(cb => {
        cb.addEventListener("change", () => {
            if (cb.checked) activeFilters.add(cb.dataset.layer);
            else activeFilters.delete(cb.dataset.layer);
            applyFilters();
        });
    });
}

const LANG_COLORS = {
    python: "#3572A5", go: "#00ADD8", java: "#B07219",
    javascript: "#F1E05A", typescript: "#3178C6", rust: "#DEA584",
    cpp: "#F34B7D", c: "#555555",
};

function renderLanguageFilters() {
    // Only show if more than one language
    if (activeLanguages.size <= 1) return;
    document.getElementById("languageFilterSection").style.display = "";

    const counts = {};
    allNodes.forEach(n => { const lang = n.language || "python"; counts[lang] = (counts[lang] || 0) + 1; });

    const container = document.getElementById("languageFilters");
    container.innerHTML = Array.from(activeLanguages).sort().map(lang => {
        const color = LANG_COLORS[lang] || "#bdbdbd";
        return `<label class="layer-filter">
            <input type="checkbox" checked data-lang="${lang}">
            <span class="layer-dot" style="background:${color}"></span>
            <span>${lang}</span>
            <span class="layer-count">${counts[lang] || 0}</span>
        </label>`;
    }).join("");

    container.querySelectorAll("input").forEach(cb => {
        cb.addEventListener("change", () => {
            if (cb.checked) activeLanguages.add(cb.dataset.lang);
            else activeLanguages.delete(cb.dataset.lang);
            applyFilters();
        });
    });
}

function renderHubModules(hubs) {
    const container = document.getElementById("hubList");
    container.innerHTML = hubs.slice(0, 10).map(h => {
        const name = shortName(h.module);
        return `<div class="metric-item" data-id="${h.module}"><span title="${h.module}">${name}</span><span>in:${h.fan_in} out:${h.fan_out}</span></div>`;
    }).join("");
    container.querySelectorAll(".metric-item").forEach(el => {
        el.addEventListener("click", () => highlightAndSelect(el.dataset.id));
    });
}

function renderAntiPatterns(patterns) {
    const container = document.getElementById("antiPatternList");
    if (!patterns.length) { container.innerHTML = '<div style="font-size:11px;color:#666;">None detected</div>'; return; }
    container.innerHTML = patterns.slice(0, 15).map((p, i) => {
        const name = shortName(p.module || "");
        const sev = p.severity === "high" ? "#e53935" : p.severity === "medium" ? "#ffa726" : "#bdbdbd";
        return `<div class="ap-item" data-id="${p.module}">
            <div class="ap-header"><span>${p.type}: ${name}</span><span style="color:${sev};font-size:10px;">${p.severity}</span></div>
            <div class="ap-details">${p.details || ''}</div>
        </div>`;
    }).join("");
    container.querySelectorAll(".ap-item").forEach(el => {
        el.addEventListener("click", () => {
            el.classList.toggle("expanded");
            if (el.dataset.id) highlightAndSelect(el.dataset.id);
        });
    });
}

function renderCycles(cycles) {
    const container = document.getElementById("cycleList");
    if (!cycles.length) { container.innerHTML = '<div style="font-size:11px;color:#666;">None detected</div>'; return; }
    container.innerHTML = cycles.slice(0, 10).map((cycle, i) => {
        const names = cycle.map(p => shortName(p));
        return `<div class="cycle-item" data-index="${i}">${names.join(' → ')} → ${names[0]}</div>`;
    }).join("");
    container.querySelectorAll(".cycle-item").forEach(el => {
        el.addEventListener("click", () => {
            const idx = parseInt(el.dataset.index);
            highlightCycle(allCycles[idx]);
        });
    });
}

function setupSidebarToggles() {
    [["hubHeader", "hubList"], ["apHeader", "antiPatternList"], ["cycleHeader", "cycleList"]].forEach(([hid, lid]) => {
        const header = document.getElementById(hid);
        const list = document.getElementById(lid);
        const toggle = header.querySelector(".section-toggle");
        header.addEventListener("click", () => {
            const open = toggle.classList.toggle("open");
            list.style.display = open ? "" : "none";
        });
    });
}

function shortName(path) {
    return (path || "").split("/").pop().replace(/\.(py|go|java|ts|tsx|js|jsx|rs|cpp|cc|c|h|hpp)$/, "");
}

function buildGraph() {
    const container = document.getElementById("graphContainer");
    const width = container.clientWidth;
    const height = container.clientHeight;

    svg = d3.select("#graphSvg");
    svg.selectAll("*").remove();

    // Zoom with semantic label visibility
    zoomBehavior = d3.zoom().scaleExtent([0.05, 8]).on("zoom", e => {
        g.attr("transform", e.transform);
        currentZoomScale = e.transform.k;
        updateLabelVisibility();
    });
    svg.call(zoomBehavior);

    // Click on empty space to deselect
    svg.on("click", (event) => {
        if (event.target.tagName === "svg") {
            closeTracer();
            resetHighlight();
        }
    });

    g = svg.append("g");

    // Arrow markers
    const defs = svg.append("defs");
    defs.append("marker")
        .attr("id", "arrowhead").attr("viewBox", "0 -5 10 10")
        .attr("refX", 20).attr("refY", 0)
        .attr("markerWidth", 5).attr("markerHeight", 5)
        .attr("orient", "auto")
        .append("path").attr("d", "M0,-4L10,0L0,4").attr("fill", "#555");

    defs.append("marker")
        .attr("id", "arrowhead-hidden").attr("viewBox", "0 -5 10 10")
        .attr("refX", 20).attr("refY", 0)
        .attr("markerWidth", 5).attr("markerHeight", 5)
        .attr("orient", "auto")
        .append("path").attr("d", "M0,-4L10,0L0,4").attr("fill", "#e53935");

    linkGroup = g.append("g").attr("class", "links");
    nodeGroup = g.append("g").attr("class", "nodes");
    labelGroup = g.append("g").attr("class", "labels");

    applyFilters();

    // Initial zoom to fit
    svg.call(zoomBehavior.transform, d3.zoomIdentity.translate(width / 2, height / 2).scale(0.7));
}

function updateLabelVisibility() {
    // For large graphs, hide labels when zoomed out to improve performance
    const nodeCount = allNodes.length;
    if (nodeCount > 500) {
        const showLabels = currentZoomScale > 0.3;
        labelGroup.style("display", showLabels ? null : "none");
    }
}

function applyFilters() {
    const query = (document.getElementById("searchInput").value || "").toLowerCase();

    const visibleNodes = allNodes.filter(n => {
        if (!activeFilters.has(n.layer)) return false;
        if (!activeLanguages.has(n.language || "python")) return false;
        if (query && !n.id.toLowerCase().includes(query) && !(n.package || "").toLowerCase().includes(query)) return false;
        return true;
    });

    const visibleIds = new Set(visibleNodes.map(n => n.id));
    const visibleLinks = allLinks.filter(l => {
        const src = typeof l.source === "object" ? l.source.id : l.source;
        const tgt = typeof l.target === "object" ? l.target.id : l.target;
        return visibleIds.has(src) && visibleIds.has(tgt);
    });

    updateGraph(visibleNodes, visibleLinks);

    // If search has results, zoom to fit them
    if (query && visibleNodes.length > 0 && visibleNodes.length < allNodes.length) {
        setTimeout(() => zoomToFit(visibleNodes), 600);
    }
}

function zoomToFit(nodes) {
    if (!nodes.length) return;
    const container = document.getElementById("graphContainer");
    const width = container.clientWidth;
    const height = container.clientHeight;
    const padding = 60;

    const xs = nodes.map(n => n.x || 0);
    const ys = nodes.map(n => n.y || 0);
    const x0 = Math.min(...xs), x1 = Math.max(...xs);
    const y0 = Math.min(...ys), y1 = Math.max(...ys);
    const dx = (x1 - x0) || 1, dy = (y1 - y0) || 1;
    const scale = Math.min((width - padding * 2) / dx, (height - padding * 2) / dy, 3);
    const cx = (x0 + x1) / 2, cy = (y0 + y1) / 2;

    svg.transition().duration(500).call(
        zoomBehavior.transform,
        d3.zoomIdentity.translate(width / 2 - cx * scale, height / 2 - cy * scale).scale(scale)
    );
}

function updateGraph(nodes, links) {
    const container = document.getElementById("graphContainer");
    const width = container.clientWidth;
    const height = container.clientHeight;

    // LOC scale for node radius
    const locExtent = d3.extent(nodes, d => d.loc || 1);
    const rScale = d3.scaleSqrt().domain([locExtent[0] || 1, locExtent[1] || 100]).range([6, 24]);

    // Curved links using paths
    const linkSel = linkGroup.selectAll("path").data(links, d => {
        const s = typeof d.source === "object" ? d.source.id : d.source;
        const t = typeof d.target === "object" ? d.target.id : d.target;
        return s + "->" + t;
    });
    linkSel.exit().remove();
    const linkEnter = linkSel.enter().append("path").attr("fill", "none");
    const linkMerge = linkEnter.merge(linkSel)
        .attr("stroke", d => d.type === "hidden" ? "#e53935" : "#555")
        .attr("stroke-width", d => d.type === "hidden" ? 1.5 : 1)
        .attr("stroke-dasharray", d => d.type === "hidden" ? "6,3" : null)
        .attr("marker-end", d => d.type === "hidden" ? "url(#arrowhead-hidden)" : "url(#arrowhead)")
        .attr("stroke-opacity", 0.4);

    // Nodes
    const nodeSel = nodeGroup.selectAll("circle.node").data(nodes, d => d.id);
    nodeSel.exit().remove();
    const nodeEnter = nodeSel.enter().append("circle").attr("class", "node").style("cursor", "pointer");
    const nodeMerge = nodeEnter.merge(nodeSel)
        .attr("r", d => rScale(d.loc || 1))
        .attr("fill", d => LAYER_COLORS[d.layer] || "#bdbdbd")
        .attr("stroke", "#fff").attr("stroke-width", 1).attr("fill-opacity", 0.85);

    // Labels
    const labelSel = labelGroup.selectAll("g.label").data(nodes, d => d.id);
    labelSel.exit().remove();
    const labelEnterG = labelSel.enter().append("g").attr("class", "label");
    // Background rect
    labelEnterG.append("rect")
        .attr("rx", 2).attr("ry", 2)
        .attr("fill", "rgba(15,20,30,0.7)").attr("stroke", "none");
    labelEnterG.append("text")
        .attr("text-anchor", "middle")
        .style("font-size", "9px").style("fill", "#ddd").style("pointer-events", "none");
    const labelMerge = labelEnterG.merge(labelSel);

    labelMerge.select("text")
        .text(d => shortName(d.id))
        .each(function() {
            const bbox = this.getBBox();
            const rect = this.parentNode.querySelector("rect");
            rect.setAttribute("x", bbox.x - 2);
            rect.setAttribute("y", bbox.y - 1);
            rect.setAttribute("width", bbox.width + 4);
            rect.setAttribute("height", bbox.height + 2);
        });

    // Interactions
    nodeMerge
        .on("mouseover", (event, d) => showTooltip(event, d))
        .on("mouseout", hideTooltip)
        .on("click", (event, d) => { event.stopPropagation(); openTracer(d); });

    // Drag
    nodeMerge.call(d3.drag()
        .on("start", (event, d) => { if (!event.active && simulation) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
        .on("drag", (event, d) => { d.fx = event.x; d.fy = event.y; })
        .on("end", (event, d) => { if (!event.active && simulation) simulation.alphaTarget(0); d.fx = null; d.fy = null; })
    );

    // Simulation with layer-based Y positioning — adapt for repo size
    if (simulation) simulation.stop();
    const isLargeRepo = nodes.length > 500;
    const chargeStrength = isLargeRepo ? -80 : -250;
    const linkDistance = isLargeRepo ? 40 : 90;
    const linkStrength = isLargeRepo ? 0.3 : 0.5;
    const collisionPad = isLargeRepo ? 2 : 5;
    const alphaDecay = isLargeRepo ? 0.05 : 0.0228; // faster convergence for large repos

    simulation = d3.forceSimulation(nodes)
        .alphaDecay(alphaDecay)
        .force("link", d3.forceLink(links).id(d => d.id).distance(linkDistance).strength(linkStrength))
        .force("charge", d3.forceManyBody().strength(chargeStrength).theta(isLargeRepo ? 0.9 : 0.8))
        .force("center", d3.forceCenter(0, 0))
        .force("collision", d3.forceCollide().radius(d => rScale(d.loc || 1) + collisionPad))
        .force("layerY", d3.forceY(d => {
            const order = LAYER_ORDER[d.layer] !== undefined ? LAYER_ORDER[d.layer] : 3;
            return (order - 2.5) * (height / 5);
        }).strength(0.08))
        .on("tick", () => {
            // Curved edges
            linkMerge.attr("d", d => {
                const dx = d.target.x - d.source.x;
                const dy = d.target.y - d.source.y;
                const dr = Math.sqrt(dx * dx + dy * dy) * 1.5;
                return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
            });
            nodeMerge.attr("cx", d => d.x).attr("cy", d => d.y);
            labelMerge.attr("transform", d => `translate(${d.x},${d.y + rScale(d.loc || 1) + 12})`);
        });
}

function showTooltip(event, d) {
    const tt = document.getElementById("tooltip");
    tt.style.display = "block";
    tt.innerHTML = `
        <div class="tt-title">${d.id}</div>
        <div class="tt-row"><span class="tt-key">Language</span><span class="tt-val">${d.language || "python"}</span></div>
        <div class="tt-row"><span class="tt-key">Layer</span><span class="tt-val">${d.layer}</span></div>
        <div class="tt-row"><span class="tt-key">LOC</span><span class="tt-val">${d.loc}</span></div>
        <div class="tt-row"><span class="tt-key">Fan-in</span><span class="tt-val">${d.fan_in}</span></div>
        <div class="tt-row"><span class="tt-key">Fan-out</span><span class="tt-val">${d.fan_out}</span></div>
        ${d.docstring ? `<div class="tt-doc">${d.docstring.slice(0, 120)}</div>` : ""}
    `;
    const container = document.getElementById("graphContainer");
    const rect = container.getBoundingClientRect();
    tt.style.left = (event.clientX - rect.left + 15) + "px";
    tt.style.top = (event.clientY - rect.top - 10) + "px";
}

function hideTooltip() {
    document.getElementById("tooltip").style.display = "none";
}

// --- Tracer Panel ---

function openTracer(d) {
    selectedNode = d.id;
    const panel = document.getElementById("tracerPanel");
    panel.classList.add("open");
    document.getElementById("tracerTitle").textContent = shortName(d.id);
    document.getElementById("tracerTitle").title = d.id;

    const body = document.getElementById("tracerBody");
    body.innerHTML = buildTracerContent(d);

    // Attach navigation click handlers
    body.querySelectorAll("[data-navigate]").forEach(el => {
        el.addEventListener("click", () => highlightAndSelect(el.dataset.navigate));
    });

    highlightDepTree(d);
}

function closeTracer() {
    selectedNode = null;
    document.getElementById("tracerPanel").classList.remove("open");
    resetHighlight();
}

function buildTracerContent(d) {
    const layerColor = LAYER_COLORS[d.layer] || "#bdbdbd";
    let html = '';

    // Module Info
    html += `<div class="tracer-section">
        <h4>Module Info</h4>
        <div class="tracer-row"><span class="key">Path</span><span class="val" style="font-size:10px;word-break:break-all;">${d.id}</span></div>
        <div class="tracer-row"><span class="key">Language</span><span class="val">${d.language || "python"}</span></div>
        <div class="tracer-row"><span class="key">Layer</span><span class="val"><span class="layer-badge" style="background:${layerColor};color:#000;">${d.layer}</span></span></div>
        <div class="tracer-row"><span class="key">LOC</span><span class="val">${d.loc || 0}</span></div>
        <div class="tracer-row"><span class="key">Classes</span><span class="val">${d.num_classes || 0}</span></div>
        <div class="tracer-row"><span class="key">Functions</span><span class="val">${d.num_functions || 0}</span></div>
        <div class="tracer-row"><span class="key">Fan-in / Fan-out</span><span class="val">${d.fan_in || 0} / ${d.fan_out || 0}</span></div>
    </div>`;

    // Docstring
    if (d.docstring) {
        const docLines = d.docstring.split('\n').slice(0, 3).join('\n');
        html += `<div class="tracer-section"><h4>Docstring</h4><div class="tracer-doc">${escapeHtml(docLines)}</div></div>`;
    }

    // Depends On
    const dependsOn = d.depends_on || [];
    html += `<div class="tracer-section"><h4>Depends On (${dependsOn.length})</h4>`;
    if (dependsOn.length) {
        html += `<ul class="dep-list">${dependsOn.map(dep =>
            `<li data-navigate="${dep}"><span class="dep-arrow">→</span> ${shortName(dep)}</li>`
        ).join("")}</ul>`;
    } else {
        html += `<div style="font-size:11px;color:#666;">No dependencies</div>`;
    }
    html += `</div>`;

    // Used By
    const usedBy = d.used_by || [];
    html += `<div class="tracer-section"><h4>Used By (${usedBy.length})</h4>`;
    if (usedBy.length) {
        html += `<ul class="dep-list">${usedBy.map(dep =>
            `<li data-navigate="${dep}"><span class="dep-arrow">←</span> ${shortName(dep)}</li>`
        ).join("")}</ul>`;
    } else {
        html += `<div style="font-size:11px;color:#666;">No dependents</div>`;
    }
    html += `</div>`;

    // Upstream dependency tree
    if (d.upstream_tree && d.upstream_tree.children && d.upstream_tree.children.length) {
        html += `<div class="tracer-section"><h4>Upstream Tree (depth 3)</h4><div class="dep-tree">${renderTree(d.upstream_tree.children)}</div></div>`;
    }

    // Downstream dependency tree
    if (d.downstream_tree && d.downstream_tree.children && d.downstream_tree.children.length) {
        html += `<div class="tracer-section"><h4>Downstream Tree (depth 3)</h4><div class="dep-tree">${renderTree(d.downstream_tree.children)}</div></div>`;
    }

    // Issues: Cycles + Anti-Patterns
    const inCycles = d.in_cycles || [];
    const nodeAps = d.node_anti_patterns || [];
    if (inCycles.length || nodeAps.length) {
        html += `<div class="tracer-section"><h4>Issues</h4><div class="issues-list">`;
        inCycles.forEach(ci => {
            const cycle = allCycles[ci];
            if (cycle) {
                const names = cycle.map(p => shortName(p));
                html += `<div class="issue-tag issue-cycle" title="Cycle ${ci}">Cycle: ${names.join(' → ')}</div>`;
            }
        });
        nodeAps.forEach(ap => {
            html += `<div class="issue-tag issue-ap" title="${escapeHtml(ap.details || '')}">${ap.type} (${ap.severity})</div>`;
        });
        html += `</div></div>`;
    }

    return html;
}

function renderTree(children) {
    if (!children || !children.length) return '';
    let html = '<ul>';
    children.forEach(child => {
        const hasChildren = child.children && child.children.length > 0;
        html += `<li data-navigate="${child.id}">`;
        if (hasChildren) {
            html += `<span class="tree-toggle" onclick="this.parentElement.classList.toggle('collapsed');event.stopPropagation();">▾</span>`;
        }
        html += `${shortName(child.id)}`;
        if (hasChildren) html += renderTree(child.children);
        html += `</li>`;
    });
    html += '</ul>';
    return html;
}

function escapeHtml(str) {
    return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

// --- Highlight Logic ---

function highlightAndSelect(nodeId) {
    const node = nodeMap[nodeId];
    if (!node) return;
    openTracer(node);
    // Pan to node
    const container = document.getElementById("graphContainer");
    const width = container.clientWidth;
    const height = container.clientHeight;
    const scale = 1.5;
    svg.transition().duration(400).call(
        zoomBehavior.transform,
        d3.zoomIdentity.translate(width / 2 - node.x * scale, height / 2 - node.y * scale).scale(scale)
    );
}

function highlightDepTree(d) {
    // Collect all transitive deps at each depth
    const depthMap = new Map(); // nodeId -> depth (0 = selected)
    depthMap.set(d.id, 0);

    function walkTree(tree, depth) {
        if (!tree || !tree.children) return;
        tree.children.forEach(child => {
            if (!depthMap.has(child.id) || depthMap.get(child.id) > depth + 1) {
                depthMap.set(child.id, depth + 1);
            }
            walkTree(child, depth + 1);
        });
    }

    // Walk both upstream and downstream trees
    if (d.upstream_tree) walkTree(d.upstream_tree, 0);
    if (d.downstream_tree) walkTree(d.downstream_tree, 0);

    // Also add direct neighbors
    (d.depends_on || []).forEach(dep => { if (!depthMap.has(dep)) depthMap.set(dep, 1); });
    (d.used_by || []).forEach(dep => { if (!depthMap.has(dep)) depthMap.set(dep, 1); });

    const maxDepth = 3;

    nodeGroup.selectAll("circle.node")
        .attr("fill-opacity", n => {
            if (depthMap.has(n.id)) {
                const depth = depthMap.get(n.id);
                return 1.0 - (depth / (maxDepth + 1)) * 0.5;
            }
            return 0.1;
        })
        .attr("stroke-width", n => n.id === d.id ? 3 : 1)
        .attr("stroke", n => n.id === d.id ? "#fff" : depthMap.has(n.id) ? "rgba(255,255,255,0.6)" : "rgba(255,255,255,0.2)");

    labelGroup.selectAll("g.label")
        .style("opacity", n => depthMap.has(n.id) ? 1 : 0.15);

    linkGroup.selectAll("path")
        .attr("stroke-opacity", l => {
            const src = typeof l.source === "object" ? l.source.id : l.source;
            const tgt = typeof l.target === "object" ? l.target.id : l.target;
            if (depthMap.has(src) && depthMap.has(tgt)) return 0.7;
            return 0.04;
        });
}

function highlightCycle(cycle) {
    if (!cycle) return;
    const cycleSet = new Set(cycle);
    // Build cycle edge set
    const cycleEdges = new Set();
    for (let i = 0; i < cycle.length; i++) {
        const src = cycle[i];
        const tgt = cycle[(i + 1) % cycle.length];
        cycleEdges.add(src + "->" + tgt);
    }

    nodeGroup.selectAll("circle.node")
        .attr("fill-opacity", n => cycleSet.has(n.id) ? 1 : 0.1)
        .attr("stroke-width", n => cycleSet.has(n.id) ? 3 : 1)
        .attr("stroke", n => cycleSet.has(n.id) ? "#e53935" : "rgba(255,255,255,0.2)");

    labelGroup.selectAll("g.label")
        .style("opacity", n => cycleSet.has(n.id) ? 1 : 0.15);

    linkGroup.selectAll("path")
        .attr("stroke-opacity", l => {
            const src = typeof l.source === "object" ? l.source.id : l.source;
            const tgt = typeof l.target === "object" ? l.target.id : l.target;
            return cycleEdges.has(src + "->" + tgt) ? 0.9 : 0.04;
        })
        .attr("stroke", l => {
            const src = typeof l.source === "object" ? l.source.id : l.source;
            const tgt = typeof l.target === "object" ? l.target.id : l.target;
            if (cycleEdges.has(src + "->" + tgt)) return "#e53935";
            return l.type === "hidden" ? "#e53935" : "#555";
        });

    // Zoom to fit cycle nodes
    const cycleNodes = allNodes.filter(n => cycleSet.has(n.id));
    if (cycleNodes.length) zoomToFit(cycleNodes);
}

function resetHighlight() {
    selectedNode = null;
    nodeGroup.selectAll("circle.node")
        .attr("fill-opacity", 0.85).attr("stroke-width", 1).attr("stroke", "#fff");
    labelGroup.selectAll("g.label").style("opacity", 1);
    linkGroup.selectAll("path")
        .attr("stroke-opacity", 0.4)
        .attr("stroke", d => d.type === "hidden" ? "#e53935" : "#555");
}

window.addEventListener("load", init);
window.addEventListener("resize", () => { if (simulation) simulation.alpha(0.3).restart(); });
</script>
</body>
</html>
